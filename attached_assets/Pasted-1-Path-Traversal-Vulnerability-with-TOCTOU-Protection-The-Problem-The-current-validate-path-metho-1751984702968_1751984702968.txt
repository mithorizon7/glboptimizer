1. Path Traversal Vulnerability with TOCTOU Protection
The Problem:
The current _validate_path method is vulnerable to symlink attacks and Time-of-Check-Time-of-Use (TOCTOU) race conditions. An attacker could validate a legitimate path, then quickly replace it with a symlink to a sensitive file before your code uses it.
Why This Is Critical:
This allows attackers to read or write files anywhere on the system, potentially accessing sensitive data or corrupting system files. The TOCTOU issue means even good validation can be bypassed.
How to Fix:
Implement validation with TOCTOU protection:
pythonimport fcntl
import os
import tempfile
from pathlib import Path

def _validate_path(self, file_path: str, allow_temp: bool = False) -> str:
    """Validate path with TOCTOU protection"""
    try:
        # Initial validation - resolve symlinks
        abs_path = os.path.realpath(os.path.abspath(file_path))
        
        # Validate file extension
        if not abs_path.lower().endswith('.glb'):
            raise ValueError(f"Path must be a .glb file: {file_path}")
        
        # For temp files, use secure session directory
        if allow_temp:
            if not hasattr(self, '_secure_temp_dir'):
                self._secure_temp_dir = tempfile.mkdtemp(prefix='glb_opt_')
                self._temp_files.add(self._secure_temp_dir)
            
            # Ensure temp file is within our secure directory
            try:
                Path(abs_path).relative_to(Path(self._secure_temp_dir))
                return abs_path
            except ValueError:
                pass
        
        # Check against allowed directories using commonpath for compatibility
        for allowed_dir in self.allowed_dirs:
            allowed_real = os.path.realpath(allowed_dir)
            if os.path.commonpath([abs_path, allowed_real]) == allowed_real:
                return abs_path
        
        raise ValueError(f"Path outside allowed directories: {file_path}")
        
    except Exception as e:
        self.logger.error(f"Path validation failed for {file_path}: {e}")
        raise ValueError(f"Invalid or unsafe file path: {file_path}")

def _safe_file_operation(self, filepath: str, operation: str, *args, **kwargs):
    """Perform file operations with TOCTOU protection"""
    # Re-validate path immediately before use
    validated_path = os.path.realpath(filepath)
    
    # Ensure it's still in allowed directories
    allowed = False
    for allowed_dir in self.allowed_dirs:
        if os.path.commonpath([validated_path, os.path.realpath(allowed_dir)]) == os.path.realpath(allowed_dir):
            allowed = True
            break
    
    if not allowed and hasattr(self, '_secure_temp_dir'):
        temp_real = os.path.realpath(self._secure_temp_dir)
        if os.path.commonpath([validated_path, temp_real]) == temp_real:
            allowed = True
    
    if not allowed:
        raise ValueError(f"Path validation failed at time of use: {filepath}")
    
    # Perform the actual operation
    if operation == 'read':
        with open(validated_path, 'rb') as f:
            return f.read()
    elif operation == 'write':
        with open(validated_path, 'wb') as f:
            return f.write(args[0])
    elif operation == 'copy':
        import shutil
        return shutil.copy2(validated_path, args[0])
    else:
        raise ValueError(f"Unknown operation: {operation}")
